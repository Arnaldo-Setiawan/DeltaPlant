<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Delta Force Tactical Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            margin: 0;
            padding: 0;
        }

        /* The Outer Map Container (The "Big Box" card) */
        .map-card-container {
            position: relative;
            max-width: 100%;
            border-radius: 0.75rem;
            box-shadow: none;
            background-color: transparent; 
            overflow: hidden;
            
            display: block; 
            margin: 0;
            padding: 0;
            line-height: 0;
        }
        
        /* Inner map container (Holds image and canvas) */
        .map-container {
            position: relative; 
            width: 100%; 
            height: 100%; 
            margin: 0; 
            cursor: crosshair; 
            transition: width 0.3s, height 0.3s; 
        }

        /* Map background image */
        #map-background {
            width: 100%;
            height: 100%; 
            object-fit: contain; 
            display: block; 
        }

        .map-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* Tooltip styling */
        .tooltip {
          position: absolute;
          visibility: hidden;
          opacity: 0;
          transition: opacity 0.3s;
          background-color: #21262d;
          color: #fff;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 0.75rem;
          white-space: nowrap;
          z-index: 100;
        }

        .tool-button:hover .tooltip {
          visibility: visible;
          opacity: 1;
        }

        /* Modal specific styling */
        #custom-modal.flex {
            display: flex;
        }
        
        /* Operator selection buttons are large enough to be clickable dots */
        .icon-selector-item {
            width: 32px; 
            height: 32px; 
            border-radius: 9999px; 
            border: 3px solid transparent;
            cursor: pointer;
            transition: transform 0.1s, border-color 0.2s;
            /* Flex properties for image centering */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .icon-selector-item.selected {
            border-color: #1d9bf0;
            transform: scale(1.2); 
            box-shadow: 0 0 10px rgba(29, 155, 240, 0.8);
        }
        
        /* Styling for the small internal icon images */
        .icon-selector-item img {
            /* INCREASED SIZE for crispness and masking in the selector UI */
            width: 30px; 
            height: 30px; 
            object-fit: cover; /* Use cover to fill the area */
            border-radius: 50%; /* Mask the image to a circle */
            overflow: hidden;
        }


        /* Brush Preview Style */
        #brush-preview {
            position: fixed;
            border-radius: 9999px; 
            pointer-events: none; 
            z-index: 1000;
            border: 2px solid;
            transition: opacity 0.1s;
        }

        /* Global fix for the scroll boundary */
        #main-wrapper {
            /* Sets the height of the wrapper to the full viewport, minus the header. */
            min-height: calc(100vh - 70px); /* 70px approx height of header */
            padding-bottom: 24px; /* Maintain bottom padding for margin below content */
        }
        


    </style>
</head>
<body>

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#1d9bf0',
                        secondary: '#2e4964',
                        background: '#0d1117',
                        card: '#161b22',
                        text: '#c9d1d9',
                    },
                }
            }
        }
    </script>

    <!-- WRAPPING DIV to handle full-height layout and scrolling -->
    <div id="main-wrapper" class="pt-0 px-4 sm:px-6 text-text"> 
        <header class="text-center mb-1"> 
            <h1 class="text-3xl sm:text-4xl font-extrabold text-primary">Delta Force Tactical Planner</h1>
            <!-- NEW: Display for the currently loaded Map and Sector -->
            <p class="text-secondary mt-2">
                Planning on: <span id="current-map-display" class="font-bold text-white">Loading Map...</span> 
                | Sector: <span id="current-sector-display" class="font-bold text-white">N/A</span>
            </p>
            <p class="text-xs text-yellow-400 mt-1">
                QOL: Use <kbd class="px-1 bg-gray-600 rounded">Ctrl+Z</kbd> (Undo) and <kbd class="px-1 bg-gray-600 rounded">Ctrl+Y</kbd> (Redo)
            </p>
        </header>
        
        <!-- Main content area. -->
        <main class="flex flex-col lg:flex-row gap-6 mt-0 lg:items-start"> 
            
            <!-- Tools Panel -->
            <div class="lg:w-1/6 w-full bg-card p-4 rounded-xl shadow-lg border border-secondary h-min space-y-6"> 
                
                <!-- Map Selector -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Map Selection</h2>
                    <select id="map-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-text focus:ring-primary focus:border-primary">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <!-- Sector Selector (NEW) -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Sector Selection</h2>
                    <select id="sector-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-text focus:ring-primary focus:border-primary">
                        <!-- Options populated by JS -->
                    </select>
                </div>
                
                <!-- SEQUENCE SELECTOR (IMPLEMENTED AGAIN) -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Sequence Control</h2>
                    <div class="flex gap-2 mb-2">
                        <select id="sequence-select" class="w-full p-2 bg-gray-700 border border-gray-600 rounded-lg text-text focus:ring-primary focus:border-primary">
                            <!-- Options populated by JS (fixed 10) -->
                        </select>
                    </div>
                </div>
                <!-- END SEQUENCE SELECTOR -->


                <!-- Operator Icon Selector -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Operator Placement (6 Operators)</h2>
                    <div id="operator-icons" class="flex flex-wrap gap-3 justify-center">
                        <!-- Icons populated by JS -->
                    </div>
                    <p id="placement-hint-operator" class="text-xs text-gray-400 mt-3 hidden text-center">Click map to place icon.</p>
                </div>
                
                <!-- NEW: UTILITY ICON SELECTOR -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Utility Placement (3 Items)</h2>
                    <div id="utility-icons" class="flex flex-wrap gap-3 justify-center">
                        <!-- Icons populated by JS -->
                    </div>
                    <p id="placement-hint-utility" class="text-xs text-gray-400 mt-3 hidden text-center">Click map to place utility.</p>
                </div>
                <!-- END NEW UTILITY ICON SELECTOR -->
                
                <!-- NEW: VEHICLE ICON SELECTOR -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Vehicle Placement (12 Items)</h2>
                    <div id="vehicle-icons" class="flex flex-wrap gap-3 justify-center">
                        <!-- Icons populated by JS -->
                    </div>
                    <p id="placement-hint-vehicle" class="text-xs text-gray-400 mt-3 hidden text-center">Click map to place vehicle.</p>
                </div>
                <!-- END NEW VEHICLE ICON SELECTOR -->


                <!-- Drawing Tools -->
                <div>
                    <h2 class="text-xl font-semibold mb-3 border-b border-secondary pb-2">Drawing Tools</h2>
                    
                    <!-- Tool Selection -->
                    <div class="mb-4">
                        <label for="tool-select" class="block text-sm font-medium mb-1">Select Tool</label>
                        <div class="grid grid-cols-4 gap-2"> 
                            <button id="tool-pen" data-tool="pen" class="tool-button p-3 bg-primary text-white rounded-lg transition hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-primary relative">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18.5 13.5l-12-12"/><path d="M2 20l1.5-1.5"/></svg>
                                <div class="tooltip top-full mt-2 left-1/2 -translate-x-1/2">Pen</div>
                            </button>
                            <button id="tool-place" data-tool="place" class="tool-button p-3 bg-gray-600 text-white rounded-lg transition hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 relative">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>
                                <div class="tooltip top-full mt-2 left-1/2 -translate-x-1/2">Place Icon</div>
                            </button>
                            <!-- NEW MOVE TOOL -->
                            <button id="tool-move" data-tool="move" class="tool-button p-3 bg-gray-600 text-white rounded-lg transition hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 relative">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto"><path d="M5 9l-3 3 3 3"/><path d="M22 12h-8M19 5l3 3-3 3"/><path d="M12 2v20"/><path d="M5 15l-3-3 3-3"/></svg>
                                <div class="tooltip top-full mt-2 left-1/2 -translate-x-1/2">Move Icon</div>
                            </button>
                            <button id="tool-eraser" data-tool="eraser" class="tool-button p-3 bg-gray-600 text-white rounded-lg transition hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-400 relative">
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="mx-auto"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12c1.1 0 2-.9 2-2V8l-6-6z"/><path d="M14 2v6h6"/></svg>
                                <div class="tooltip top-full mt-2 left-1/2 -translate-x-1/2">Eraser (Lines Only)</div>
                            </button>
                        </div>
                    </div>

                    <!-- Line Width -->
                    <div class="mb-4">
                        <label for="line-width" class="block text-sm font-medium mb-1">Brush/Eraser Size</label>
                        <input type="range" id="line-width" min="2" max="30" value="8" class="w-full h-2 bg-secondary rounded-lg appearance-none cursor-pointer range-lg">
                        <span id="width-display" class="text-xs mt-1 block text-right">8px</span>
                    </div>

                    <!-- Color Picker -->
                    <div>
                        <label for="color-picker" class="block text-sm font-medium mb-1">Stroke Color</label>
                        <input type="color" id="color-picker" value="#ff0000" class="w-full h-10 p-1 border border-secondary rounded-lg cursor-pointer">
                    </div>
                </div>

                <!-- Actions -->
                <div class="pt-4 border-t border-secondary space-y-3">
                    <div class="grid grid-cols-2 gap-2">
                        <button id="undo-button" class="py-2 px-4 bg-gray-700 text-white font-semibold rounded-lg hover:bg-gray-600 transition focus:outline-none focus:ring-2 focus:ring-gray-400 disabled:opacity-50" disabled>
                            Undo (Z)
                        </button>
                        <button id="redo-button" class="py-2 px-4 bg-gray-700 text-white font-semibold rounded-lg hover:bg-gray-600 transition focus:outline-none focus:ring-2 focus:ring-gray-400 disabled:opacity-50" disabled>
                            Redo (Y)
                        </button>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-2">
                        <!-- NEW CLEAR LINES BUTTON -->
                        <button id="clear-lines" class="w-full py-2 px-4 bg-yellow-700 text-white font-semibold rounded-lg hover:bg-yellow-600 transition focus:outline-none focus:ring-2 focus:ring-yellow-500">
                            Clear Lines
                        </button>
                        <!-- CLEAR MAP BUTTON (Clears everything) -->
                        <button id="clear-map" class="w-full py-2 px-4 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-600 transition focus:outline-none focus:ring-2 focus:ring-red-500">
                            Clear ALL
                        </button>
                    </div>
                    
                    <button id="save-map" class="w-full py-2 px-4 bg-green-700 text-white font-semibold rounded-lg hover:bg-green-600 transition focus:outline-none focus:ring-2 focus:ring-green-500">
                            Save Image
                        </button>
                    <p class="text-xs text-gray-400 text-center">Saves the plan (Map + Drawings)</p>
                </div>

            </div>

            <!-- Map Area -->
            <!-- CRITICAL FIX: Simplified classes to prevent vertical centering -->
            <div class="lg:w-5/6 w-full" style="position: relative;"> 
                
                <!-- map-card-wrapper uses CSS padding hack for height -->
                <div id="map-card-wrapper" class="map-card-container" style="border-radius: 0.75rem;">
                    <!-- map-container is absolutely positioned to cover map-card-wrapper -->
                    <div class="map-container" id="map-container"> 
                        <!-- The image is now contained within the JS-sized map-container -->
                        <img id="map-background" class="w-full h-full object-contain rounded-xl" alt="Delta Force Map" /> 
                        <canvas id="drawing-canvas" class="map-canvas rounded-xl"></canvas>
                        <!-- NEW: Trash Can for Deleting Icons -->
                        <div id="trash-can" class="absolute bottom-4 right-4 p-3 bg-red-700/80 rounded-full shadow-lg transition-all duration-200 z-40 hidden opacity-0 border border-red-900" 
                             title="Drag icon here to delete">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-white">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>

        </main>
    </div>
    
    <!-- Brush Size Preview Element -->
    <div id="brush-preview" class="fixed rounded-full pointer-events-none transition-opacity duration-100 ease-out hidden" 
         style="border: 2px solid; z-index: 1000; top: 0; left: 0;">
    </div>

    <!-- Custom Modal UI for Confirmation -->
    <div id="custom-modal" class="fixed inset-0 bg-black bg-opacity-75 hidden items-center justify-center z-50">
        <div class="bg-card p-6 rounded-xl shadow-2xl w-full max-w-sm border border-secondary">
            <p id="modal-message" class="text-lg mb-6 text-text font-semibold">Are you sure you want to clear all drawings? This cannot be undone.</p>
            <div class="flex justify-end space-x-3">
                <button id="modal-cancel" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500 transition">
                    Cancel
                </button>
                <button id="modal-confirm" class="px-4 py-2 bg-red-700 text-white font-semibold rounded-lg hover:bg-red-600 transition">
                    Clear
                </button>
            </div>
        </div>
    </div>

    <script type="module">
        // == CONFIGURATION (ALL URLS ARE HTTPS HOSTED FOR EXPORT COMPATIBILITY) ==
        
        const MAPS = [
            { 
                name: "Map 1: Trenchline", 
                sectors: [
                    { name: "A", url: 'https://i.imgur.com/nEuxvg4_d.jpeg?maxwidth=520&shape=thumb&fidelity=high' }, 
                    { name: "B", url: 'https://i.imgur.com/VzXL3e1_d.png?maxwidth=520&shape=thumb&fidelity=high' }, 
                    { name: "C", url: 'https://i.imgur.com/ZjUkRtT_d.png?maxwidth=520&shape=thumb&fidelity=high' }, 
                    { name: "D", url: 'https://i.imgur.com/a8xaqzW_d.png?maxwidth=520&shape=thumb&fidelity=high' },
                    { name: "E", url: 'https://i.imgur.com/0a3Xwya.png' }
                ]
            },
            { 
                name: "Map 2: Ascension", 
                sectors: [
                    { name: "A", url: 'https://placehold.co/800x600/7a4f6d/ffffff?text=Ascension+A' },
                    { name: "B", url: 'https://placehold.co/800x600/7a4f6d/ffffff?text=Ascension+B' },
                    { name: "C", url: 'https://placehold.co/800x600/7a4f6d/ffffff?text=Ascension+C' },
                    { name: "D", url: 'https://placehold.co/800x600/7a4f6d/ffffff?text=Ascension+D' }
                ]
            },
            { 
                name: "Map 3: Cracked", 
                sectors: [
                    { name: "A", url: 'https://cdn.discordapp.com/attachments/773856422148571157/1422999498409377953/crackeda.png?ex=68deb70e&is=68dd658e&hm=684cd2048cb51df3e54589868a48f4d6562d47d8357c1ab667a22abef70001c2&' },
                    { name: "B", url: 'https://cdn.discordapp.com/attachments/773856422148571157/1422999499021881446/crackedb.png?ex=68deb70e&is=68dd658e&hm=cb46034638878a742c39e7a6cd0fac05876c2a17b9035824e7479fc64ce3e66b&' },
                    { name: "C", url: 'https://placehold.co/800x800/6d7a4f/ffffff?text=Cracked+C' }
                ]
            },
            { 
                name: "Map 4: Knife Edge", 
                sectors: [
                    { name: "A", url: 'https://placehold.co/800x400/4f7a6d/ffffff?text=Knife+Edge+A' },
                    { name: "B", url: 'https://placehold.co/800x400/4f7a6d/ffffff?text=Knife+Edge+B' },
                    { name: "C", url: 'https://placehold.co/800x400/4f7a6d/ffffff?text=Knife+Edge+C' },
                ]
            },
            { 
                name: "Map 5: Shafted", 
                sectors: [
                    { name: "A", url: 'https://placehold.co/800x500/7a4f4f/ffffff?text=Shafted+A' },
                    { name: "B", url: 'https://placehold.co/800x500/7a4f4f/ffffff?text=Shafted+B' },
                    { name: "C", url: 'https://placehold.co/800x500/7a4f4f/ffffff?text=Shafted+C' }
                ]
            },
            { 
                name: "Map 6: Threshold", 
                sectors: [
                    { name: "A", url: 'https://cdn.discordapp.com/attachments/773856422148571157/1422999425332285450/thresholda.png?ex=68deb6fd&is=68dd657d&hm=a554781e6ee3fd9399a8d32ce0e84dc152662a463a132e2b892ab4e28f093241&' },
                    { name: "B", url: 'https://cdn.discordapp.com/attachments/773856422148571157/1422999426091319377/thresholdb.png?ex=68deb6fd&is=68dd657d&hm=5ca2e3030842defd621d612756bad12d0d0bbcb668f415f080dd373164bbf448&' },
                    { name: "C", url: 'https://cdn.discordapp.com/attachments/773856422148571157/1422999427081179166/thresholdc.png?ex=68deb6fd&is=68dd657d&hm=6af1f8eaf43894dfe4c7f8a6db2e91c902570a90fbf44c5649293c11d6636708&' }
                ]
            },
            { 
                name: "Map 7: Cyclone", 
                sectors: [
                    { name: "A", url: 'https://placehold.co/800x700/648a74/ffffff?text=Cyclone+A' },
                    { name: "B", url: 'https://placehold.co/800x700/648a74/ffffff?text=Cyclone+B' },
                    { name: "C", url: 'https://placehold.co/800x700/648a74/ffffff?text=Cyclone+C' },
                    { name: "D", url: 'https://placehold.co/800x700/648a74/ffffff?text=Cyclone+D' },
                    { name: "E", url: 'https://placehold.co/800x700/648a74/ffffff?text=Cyclone+E' }
                ]
            },
            { 
                name: "Map 8: Fault", 
                sectors: [
                    { name: "A", url: 'https://placehold.co/800x550/8a7464/ffffff?text=Fault+A' },
                    { name: "B", url: 'https://placehold.co/800x550/8a7464/ffffff?text=Fault+B' },
                    { name: "C", url: 'https://placehold.co/800x550/8a7464/ffffff?text=Fault+C' }
                ]
            },
            { 
                name: "Map 9: Trainwreck", 
                sectors: [
                    { name: "A", url: 'https://placehold.co/800x650/4f6d8a/ffffff?text=Trainwreck+A' },
                    { name: "B", url: 'https://placehold.co/800x650/4f6d8a/ffffff?text=Trainwreck+B' },
                    { name: "C", url: 'https://placehold.co/800x650/4f6d8a/ffffff?text=Trainwreck+C' },
                    { name: "D", url: 'https://placehold.co/800x650/4f6d8a/ffffff?text=Trainwreck+D' }
                ]
            },
        ];

        // 6 Operators defined by their color only.
        const OPERATORS = [
            { id: "op_rusher1", color: '#ff33ff', type: 'color', iconUrl: '' }, 
            { id: "op_rusher2", color: '#fcdf03', type: 'color', iconUrl: '' }, 
            { id: "op_flank", color: '#fc0303', type: 'color', iconUrl: '' },   
            { id: "op_engineer", color: '#03fc41', type: 'color', iconUrl: '' }, 
            { id: "op_scout", color: '#33aaff', type: 'color', iconUrl: '' },    
            { id: "op_enemy", color: '#fcb103', type: 'color', iconUrl: ''}     
        ];

        // NEW CONFIGURATION FOR UTILITY ICONS (Using placeholder public URLs for stability)
        const UTILITIES = [
            { 
                id: "utility_beacon", 
                color: '#ffffff', // White circle background
                type: 'image', 
                iconUrl: 'https://i.imgur.com/0jj5Jtg.png' 
            }, 
            { 
                id: "utility_mine", 
                color: '#ffffff', 
                type: 'image', 
                iconUrl: 'https://i.imgur.com/ZlSQOQD.png' 
            }, 
            { 
                id: "utility_ads", 
                color: '#ffffff', 
                type: 'image', 
                iconUrl: 'https://i.imgur.com/cURoWsM.png' 
            } 
        ];

        const VEHICLES = [
            { id: "vehicle_tank", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=T' }, 
            { id: "vehicle_lav_aa", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=A' }, 
            { id: "vehicle_lav_g1", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=L' },   
            { id: "vehicle_assault_veh", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=V' }, 
            { id: "vehicle_atv", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=A' },    
            { id: "vehicle_fsv", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=F' },     
            { id: "vehicle_light_tank", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=LT' }, 
            { id: "vehicle_assault_boat", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=B' }, 
            { id: "vehicle_jet_ski", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=S' }, 
            { id: "vehicle_assault_heli", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=AH' }, 
            { id: "vehicle_recon_heli", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=RH' }, 
            { id: "vehicle_jet", color: '#ffffff', type: 'image', iconUrl: 'https://placehold.co/30/000000/ffffff?text=J' }
        ];

        // Combine all selectable icons into one list for centralized logic
        const SELECTABLE_ICONS = [...OPERATORS, ...UTILITIES, ...VEHICLES];

        // =========================================================================

        // == CANVAS AND CONTEXT SETUP ==
        const mapContainer = document.getElementById('map-container');
        const mapCardWrapper = document.getElementById('map-card-wrapper'); // New wrapper element
        const mapBackground = document.getElementById('map-background');
        const canvas = document.getElementById('drawing-canvas'); // VISIBLE CANVAS
        const ctx = canvas.getContext('2d');
        
        // OFF-SCREEN CANVAS for storing only lines/strokes
        const lineBuffer = document.createElement('canvas');
        const lineBufferCtx = lineBuffer.getContext('2d');

        const OPERATOR_DOT_RADIUS = 5; 
        const UTILITY_IMAGE_DIAMETER = 15; // *** CRITICAL: 15 pixels diameter on the canvas ***
        const ICON_HIT_AREA = 15; 
        
        // --- NEW: Image Cache ---
        const utilityImageCache = {};
        
        function preloadUtilityImages() {
            // Create a robust fallback image (White Cross SVG)
            const fallbackImg = new Image();
            // Simple white cross SVG
            fallbackImg.src = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cline x1='10' y1='50' x2='90' y2='50' stroke='white' stroke-width='10' stroke-linecap='round'/%3E%3Cline x1='50' y1='10' x2='50' y2='90' stroke='white' stroke-width='10' stroke-linecap='round'/%3E%3C/svg%3E";


            UTILITIES.forEach(ut => {
                const img = new Image();
                img.crossOrigin = "Anonymous"; // Set crossOrigin for hosted assets
                img.onload = () => {
                    // Store the working Image object.
                    utilityImageCache[ut.iconUrl] = img;
                    console.log(`Preloaded: ${ut.iconUrl}`);
                };
                img.onerror = () => {
                    console.error(`Error loading utility image: ${ut.iconUrl}. Falling back to SVG.`);
                    // Store the fallback SVG image instead of the broken local file path image.
                    utilityImageCache[ut.iconUrl] = fallbackImg;
                };
                img.src = ut.iconUrl;
            });

            VEHICLES.forEach(v => {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.onload = () => {
                    utilityImageCache[v.iconUrl] = img;
                    console.log(`Preloaded: ${v.iconUrl}`);
                };
                img.onerror = () => {
                    console.error(`Error loading vehicle image: ${v.iconUrl}. Falling back to SVG.`);
                    utilityImageCache[v.iconUrl] = fallbackImg;
                };
                img.src = v.iconUrl;
            });
            
            // Ensure the SVG is loaded immediately for use as a fallback if the local file fails.
            if (!utilityImageCache[fallbackImg.src]) {
                utilityImageCache[fallbackImg.src] = fallbackImg;
            }
        }
        
        // == HISTORY STATE (UNDO/REDO) ==
        // History now stores objects: { lineData: string, icons: Array<{x, y, color, type, url}> }
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY_SIZE = 100; // <<< ADJUSTED HISTORY LIMIT

        // == SEQUENCE STATE (NEW) ==
        // Sequence data is now managed here, independently of history (lines)
        let planningData = {}; // { map_sector_key: { sequenceId: { icons: [], lineData: 'base64' } } }
        let currentMapKey = ''; // Key to access planningData: e.g., 'Map 1: Trenchline_A'
        let currentSequenceId = 'Seq 1';
        let placedIcons = []; // ALIAS: points to planningData[currentMapKey][currentSequenceId].icons
        const MAX_SEQUENCES = 10; // New constant for fixed sequences

        // == ANIMATION STATE (NEW) ==
        let isAnimating = false;
        let animationStartTime = 0;
        let animationFrameId = null;
        let startIconPositions = [];
        
        // == GLOBAL STATE ==
        let currentMapIndex = 0;
        let currentSectorName = "";
        let mapNaturalWidth = 0;
        let mapNaturalHeight = 0;
        
        // == TOOL STATE ==
        let isDrawing = false;
        let isMovingIcon = false; 
        let movingIconIndex = -1; 
        let currentTool = 'pen';
        let currentLineWidth = 8;
        let currentColor = '#ff0000';
        let lastX = 0;
        let lastY = 0;
        let mapLoaded = false;
        // NEW: Tracks the ID of the selected icon from SELECTABLE_ICONS
        let selectedIcon = SELECTABLE_ICONS[0]; 

        // == DOM ELEMENTS ==
        const mapSelect = document.getElementById('map-select');
        const sectorSelect = document.getElementById('sector-select');
        const sequenceSelect = document.getElementById('sequence-select'); // NEW
        // Sequence elements removed
        const operatorIconsContainer = document.getElementById('operator-icons');
        const utilityIconsContainer = document.getElementById('utility-icons'); 
        const vehicleIconsContainer = document.getElementById('vehicle-icons'); // NEW
        const placementHintOperator = document.getElementById('placement-hint-operator');
        const placementHintUtility = document.getElementById('placement-hint-utility');
        const placementHintVehicle = document.getElementById('placement-hint-vehicle'); // NEW
        const toolButtons = document.querySelectorAll('.tool-button');
        const lineWidthInput = document.getElementById('line-width');
        const widthDisplay = document.getElementById('width-display');
        const colorPicker = document.getElementById('color-picker');
        const clearButton = document.getElementById('clear-map');
        const clearLinesButton = document.getElementById('clear-lines'); 
        const saveButton = document.getElementById('save-map');
        const undoButton = document.getElementById('undo-button');
        const redoButton = document.getElementById('redo-button');
        const brushPreview = document.getElementById('brush-preview');
        const trashCan = document.getElementById('trash-can'); 
        
        // Header Display Elements
        const currentMapDisplay = document.getElementById('current-map-display');
        const currentSectorDisplay = document.getElementById('current-sector-display');
        
        // Modal elements
        const customModal = document.getElementById('custom-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmButton = document.getElementById('modal-confirm');
        const modalCancelButton = document.getElementById('modal-cancel');
        let currentModalCallback = null;

        // =========================================================================
        // 0. MODAL / UI FUNCTIONS
        // =========================================================================
        
        // Easing function (EaseInOutCubic)
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // Main Animation Loop (NEW)
        function animateSequence(timestamp) {
            if (!animationStartTime) {
                animationStartTime = timestamp;
            }

            const elapsed = timestamp - animationStartTime;
            const progress = Math.min(1, elapsed / ANIMATION_DURATION);
            const easedProgress = easeInOutCubic(progress);
            
            const targetIcons = placedIcons; 

            // Interpolate based on stored start positions and current sequence end positions
            const interpolatedIcons = targetIcons.map((icon) => {
                // Find the starting position of this specific icon (by its unique ID)
                const start = startIconPositions.find(startIcon => startIcon.id === icon.id);
                const end = icon; 

                // If icon exists in the previous sequence snapshot
                if (start) {
                    return {
                        ...icon,
                        x: start.x + (end.x - start.x) * easedProgress,
                        y: start.y + (end.y - start.y) * easedProgress
                    };
                }
                // If icon is new (or not in the previous sequence), it appears instantly at the end point.
                return icon;
            }).filter(icon => icon !== undefined);

            // Draw the interpolated frame
            drawFrame(currentSequenceId, interpolatedIcons);

            if (progress < 1) {
                animationFrameId = requestAnimationFrame(animateSequence);
            } else {
                // Animation finished: ensure the final state is drawn and update state
                isAnimating = false;
                animationStartTime = 0;
                animationFrameId = null;
                // Draw the final state from the actual placedIcons array
                drawFrame(currentSequenceId, placedIcons); 
            }
        }
        
        // Draws the current line data + the provided icon list (NEW)
        function drawFrame(sequenceId, iconList) {
             if (!mapLoaded) return;
             
             // 1. Clear the visible canvas immediately
             ctx.clearRect(0, 0, canvas.width, canvas.height);
 
             // 2. Draw lines from the off-screen line buffer immediately
             ctx.globalCompositeOperation = 'source-over';
             ctx.drawImage(lineBuffer, 0, 0);
 
             // 3. Draw icons from the provided list
             redrawIcons(iconList);
        }
        
        function updateUndoRedoButtons() {
            undoButton.disabled = historyIndex <= 0;
            redoButton.disabled = history.length === 0 || historyIndex >= history.length - 1;
        }

        function showConfirm(message, callback, confirmText = "Clear") {
            modalMessage.textContent = message;
            modalConfirmButton.textContent = confirmText;
            currentModalCallback = callback;
            customModal.classList.add('flex');
            customModal.classList.remove('hidden');
        }

        modalConfirmButton.addEventListener('click', () => {
            if (currentModalCallback) {
                currentModalCallback(true);
            }
            customModal.classList.add('hidden');
            customModal.classList.remove('flex');
            currentModalCallback = null;
        });

        modalCancelButton.addEventListener('click', () => {
            if (currentModalCallback) {
                currentModalCallback(false);
            }
            customModal.classList.add('hidden');
            customModal.classList.remove('flex');
            currentModalCallback = null;
        });
        
        function updateHeaderDisplay() {
            const map = MAPS[currentMapIndex];
            currentMapDisplay.textContent = map ? map.name : "N/A";
            currentSectorDisplay.textContent = currentSectorName || "N/A";
        }
        
        // =========================================================================
        // SEQUENCE MANAGEMENT (NEW - Fixed 10 sequences)
        // =========================================================================

        function generateMapKey(mapIndex, sectorName) {
            const mapName = MAPS[mapIndex]?.name || 'Unknown Map';
            return `${mapName}_${sectorName}`;
        }
        
        // Function to copy lines and icons from Seq 1 to all others upon first icon placement
        function performInitialSequenceCopy(mapKey) {
            const seq1Data = planningData[mapKey]['Seq 1'];
            
            if (seq1Data && seq1Data.icons.length > 0) {
                 for (let i = 2; i <= MAX_SEQUENCES; i++) {
                    const seqId = `Seq ${i}`;
                    // Deep copy Seq 1's content into Seq 2-10
                    planningData[mapKey][seqId].icons = JSON.parse(JSON.stringify(seq1Data.icons));
                    planningData[mapKey][seqId].lineData = seq1Data.lineData;
                 }
                 console.log('Initial icon and line layout copied to all sequences.');
            }
        }


        function initializeSequenceData(mapKey) {
            let newlyInitialized = false;
            if (!planningData[mapKey]) {
                planningData[mapKey] = {};
                newlyInitialized = true;
            }
            
            // 1. Initialize all 10 slots
            for (let i = 1; i <= MAX_SEQUENCES; i++) {
                const seqId = `Seq ${i}`;
                
                // If this slot is completely new OR if the whole map was just initialized
                if (newlyInitialized || !planningData[mapKey][seqId]) {
                    // CRITICAL: Each sequence now stores an object with separate icon and line data
                    planningData[mapKey][seqId] = {
                        icons: [],
                        lineData: '' // Base64 snapshot of the line buffer
                    };
                }
            }
            
            // 2. Set the current alias
            currentSequenceId = 'Seq 1';
            // ALIAS placedIcons to the icons array of the current sequence
            placedIcons = planningData[mapKey][currentSequenceId].icons;
            
            // 3. Restore line data for the initial sequence
            const initialLineData = planningData[mapKey][currentSequenceId].lineData;
            if (initialLineData) {
                const lineSnapshot = new Image();
                lineSnapshot.onload = () => {
                    lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height);
                    lineBufferCtx.drawImage(lineSnapshot, 0, 0);
                    synchronousRedraw();
                };
                lineSnapshot.src = initialLineData;
            } else {
                // If no initial data, clear both buffers
                lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }


            // Re-populate selector and set default to Seq 1
            populateSequenceSelector();
            sequenceSelect.value = currentSequenceId;
        }


        function populateSequenceSelector() {
            const mapData = planningData[currentMapKey];
            if (!mapData) return;

            sequenceSelect.innerHTML = '';
            for (let i = 1; i <= MAX_SEQUENCES; i++) {
                 const seqId = `Seq ${i}`;
                 // Ensure sequence exists in data structure before populating selector
                 if (mapData[seqId]) {
                    sequenceSelect.innerHTML += `<option value="${seqId}">${seqId}</option>`;
                 }
            }
            
            // Restore current selection
            sequenceSelect.value = currentSequenceId;
        }


        function switchSequence(newSequenceId) {
            if (currentSequenceId === newSequenceId || isAnimating || !planningData[currentMapKey]) {
                return;
            }
            
            const mapData = planningData[currentMapKey];
            const oldSequenceId = currentSequenceId;
            const newSeqData = mapData[newSequenceId];
            
            if (!newSeqData) return;
            
            // 1. SAVE the current state (lines + icons) into the OLD sequence slot
            mapData[oldSequenceId].icons = JSON.parse(JSON.stringify(placedIcons));
            mapData[oldSequenceId].lineData = lineBuffer.toDataURL(); // SAVE LINE DATA
            saveState(); 

            // --- COPY ICONS/LINES LOGIC ---
            const oldIcons = mapData[oldSequenceId].icons || [];
            
            if (newSeqData.icons.length === 0 && oldIcons.length > 0) {
                 // If the target is empty, copy the contents of the previous sequence (icons + lines)
                 newSeqData.icons.push(...JSON.parse(JSON.stringify(oldIcons)));
                 newSeqData.lineData = mapData[oldSequenceId].lineData; // COPY LINE DATA
            }

            // 2. Setup Animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            isAnimating = true;
            animationStartTime = 0;
            
            // Snapshot the starting positions for interpolation
            startIconPositions = oldIcons.map(icon => ({ x: icon.x, y: icon.y, id: icon.id }));
            
            // 3. RESTORE line data for the NEW sequence
            const newLineData = newSeqData.lineData;
            
            lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height); // CLEAR old lines
            
            if (newLineData) {
                const lineSnapshot = new Image();
                lineSnapshot.onload = () => {
                    lineBufferCtx.drawImage(lineSnapshot, 0, 0);
                    // Force a synchronous redraw after restoring lines and before starting animation
                    synchronousRedraw();
                };
                lineSnapshot.src = newLineData;
            }
            
            // 4. Update global state pointers to the new sequence
            currentSequenceId = newSequenceId;
            placedIcons = newSeqData.icons; // ALIAS switch
            
            // 5. Start animation
            animationFrameId = requestAnimationFrame(animateSequence);
            
            // 6. Update UI immediately
            sequenceSelect.value = newSequenceId;
        }

        // =========================================================================
        // 1. INITIALIZATION & RESIZING
        // =========================================================================

        let currentMapImage = new Image();
        currentMapImage.crossOrigin = "Anonymous"; // Set crossOrigin for the main map image

        function populateSectorSelector(mapIndex) {
            const map = MAPS[mapIndex];
            if (map && map.sectors && map.sectors.length > 0) {
                sectorSelect.innerHTML = map.sectors.map((sector) => 
                    `<option value="${sector.url}">${sector.name}</option>`
                ).join('');
                sectorSelect.disabled = false;
                
                const firstSector = map.sectors[0];
                sectorSelect.value = firstSector.url; 
                currentSectorName = firstSector.name;
                loadMap(firstSector.url); 

            } else {
                sectorSelect.innerHTML = '<option value="">No sectors defined</option>';
                sectorSelect.disabled = true;
                currentSectorName = "N/A";
                loadMap(''); 
            }
            updateHeaderDisplay();
        }

        function loadMap(url) {
            mapLoaded = false;
            if (!url) {
                mapBackground.src = '';
                canvas.width = 0;
                canvas.height = 0;
                mapLoaded = true;
                clearDrawing(false, true); 
                return;
            }

            mapBackground.src = url;
            currentMapImage.src = url;
            currentMapImage.crossOrigin = "Anonymous"; // Set CORS for Canvas to draw map

            currentMapImage.onload = () => {
                mapLoaded = true;
                mapNaturalWidth = currentMapImage.naturalWidth;
                mapNaturalHeight = currentMapImage.naturalHeight;
                resizeCanvas();
                
                // Determine map key and initialize sequence data
                const selectedMap = MAPS[mapSelect.value];
                const selectedSector = sectorSelect.options[sectorSelect.selectedIndex]?.text || 'A';
                currentMapKey = generateMapKey(mapSelect.value, selectedSector);
                
                // CRITICAL: Initialize sequence data and set placedIcons alias
                initializeSequenceData(currentMapKey);
                
                // --- Reset drawing history (lines only) ---
                history = [];
                historyIndex = -1;
                lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height); 
                ctx.clearRect(0, 0, canvas.width, canvas.height); 
                
                // Manually inject a clean, empty line state as history[0]
                const emptyState = { lineData: canvas.toDataURL(), icons: placedIcons.map(icon => ({ x: icon.x, y: icon.y, type: icon.type, color: icon.color, iconUrl: icon.iconUrl, id: icon.id })) }; // Ensure empty history state uses current icon set if any exist
                history.push(emptyState);
                historyIndex = 0;
                updateUndoRedoButtons();
                
                // Draw the icons for the initial sequence
                synchronousRedraw();
                console.log('New sector map loaded and sequences ready.');
            };
            currentMapImage.onerror = () => {
                console.error("Error loading sector image. Check the URL.");
                mapLoaded = true;
                mapNaturalWidth = 800; 
                mapNaturalHeight = 800;
                resizeCanvas();
                clearDrawing(false, true);
            };
        }

        // The JS now sets the aspect ratio via CSS padding-bottom
        function resizeCanvas() {
            // Use fallback aspect ratio if natural dimensions are zero (direct file open/loading error)
            const fallbackAspectRatio = 16 / 9;
            const finalAspectRatio = (mapNaturalWidth === 0 || mapNaturalHeight === 0) 
                                     ? fallbackAspectRatio 
                                     : (mapNaturalHeight / mapNaturalWidth);
                                     
            // 1. Calculate the Aspect Ratio percentage (Height / Width)
            const aspectRatioPercent = finalAspectRatio * 100;

            // 2. Apply it to the CSS padding hack wrapper
            mapCardWrapper.style.paddingBottom = `${aspectRatioPercent}%`;

            // 3. Get the final rendered dimensions (which now respects the aspect ratio)
            const mapRect = mapContainer.getBoundingClientRect();
            const newWidth = mapRect.width;
            const newHeight = mapRect.height; 

            // 4. Set canvas and buffer sizes to match the container
            canvas.width = newWidth;
            canvas.height = newHeight;
            lineBuffer.width = newWidth;
            lineBuffer.height = newHeight;

            // Don't call restoreState() on resize, call synchronousRedraw() after map load is complete
            if (mapLoaded) {
                 synchronousRedraw();
            }
        }


        function populateMapSelector() {
            mapSelect.innerHTML = MAPS.map((map, index) => 
                `<option value="${index}">${map.name}</option>`
            ).join('');
            mapSelect.value = 0;
            currentMapIndex = 0;
            populateSectorSelector(currentMapIndex);
        }
        
        function handleIconSelection(e) {
            const iconId = e.currentTarget.dataset.iconId;
            const icon = SELECTABLE_ICONS.find(i => i.id === iconId);
            
            if (icon) {
                selectedIcon = icon;
                
                // Remove selected class from all icons
                document.querySelectorAll('.icon-selector-item').forEach(dot => dot.classList.remove('selected'));
                // Add selected class to the clicked icon
                e.currentTarget.classList.add('selected');
                
                // Automatically switch to placement tool
                document.getElementById('tool-place').click(); 
            }
        }

        function populateOperatorSelector() {
            operatorIconsContainer.innerHTML = OPERATORS.map(op => 
                `<div data-icon-id="${op.id}" class="icon-selector-item ${op.id === selectedIcon.id ? 'selected' : ''}" style="background-color: ${op.color};" title="${op.id}"></div>`
            ).join('');

            document.querySelectorAll('#operator-icons .icon-selector-item').forEach(icon => {
                icon.addEventListener('click', handleIconSelection);
            });
        }
        
        // NEW: Populate utility bar
        function populateUtilitySelector() {
            utilityIconsContainer.innerHTML = UTILITIES.map(ut => 
                `<div data-icon-id="${ut.id}" class="icon-selector-item ${ut.id === selectedIcon.id ? 'selected' : ''}" style="border-radius: 50%; border: 3px solid transparent; overflow: hidden;" title="${ut.id}">
                    <!-- Image size for selector UI is 30x30, clipped to a circle via CSS -->
                    <img src="${ut.iconUrl}" alt="${ut.id}" style="width: 30px; height: 30px; object-fit: cover; border-radius: 50%;">
                </div>`
            ).join('');

            document.querySelectorAll('#utility-icons .icon-selector-item').forEach(icon => {
                icon.addEventListener('click', handleIconSelection);
            });
        }
        
        // NEW: Populate vehicle selector
        function populateVehicleSelector() {
            vehicleIconsContainer.innerHTML = VEHICLES.map(v => 
                `<div data-icon-id="${v.id}" class="icon-selector-item ${v.id === selectedIcon.id ? 'selected' : ''}" style="background-color: ${v.color};" title="${v.id}">
                    <!-- Image/Text for selector UI -->
                    <img src="${v.iconUrl}" alt="${v.id}" style="width: 30px; height: 30px; object-fit: cover; border-radius: 50%;">
                </div>`
            ).join('');

            document.querySelectorAll('#vehicle-icons .icon-selector-item').forEach(icon => {
                icon.addEventListener('click', handleIconSelection);
            });
        }


        // =========================================================================
        // 2. HISTORY (UNDO/REDO)
        // =========================================================================

        // Draws a single icon (color dot or image)
        function drawSingleIcon(icon) {
            const radius = icon.type === 'color' ? OPERATOR_DOT_RADIUS : UTILITY_IMAGE_DIAMETER / 2;
            const size = icon.type === 'color' ? OPERATOR_DOT_RADIUS * 2 : UTILITY_IMAGE_DIAMETER;
            const drawX = icon.x - radius;
            const drawY = icon.y - radius;

            ctx.globalCompositeOperation = 'source-over';
            
            // 1. Draw border/shadow
            ctx.beginPath();
            ctx.arc(icon.x, icon.y, radius + 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)'; 
            ctx.fill();

            if (icon.type === 'color') {
                // 2. Draw the colored dot
                ctx.beginPath();
                ctx.arc(icon.x, icon.y, radius, 0, Math.PI * 2);
                ctx.fillStyle = icon.color;
                ctx.fill();
            } else if (icon.type === 'image') {
                // 2. Draw the background circle for the image
                 ctx.beginPath();
                 ctx.arc(icon.x, icon.y, radius, 0, Math.PI * 2);
                 ctx.fillStyle = icon.color || '#ffffff'; // Fallback circle color
                 ctx.fill();
                 
                // 3. Draw the image (synchronously using the cache)
                const img = utilityImageCache[icon.iconUrl];

                if (img) {
                    const isFallback = img.src.startsWith("data:image/svg+xml");
                    
                    if (!isFallback) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(icon.x, icon.y, radius, 0, Math.PI * 2);
                        ctx.clip(); 
                    }

                    ctx.drawImage(img, drawX, drawY, size, size);

                    if (!isFallback) {
                        ctx.restore(); 
                    }
                } else {
                    const fallbackImg = utilityImageCache["data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cline x1='10' y1='50' x2='90' y2='50' stroke='white' stroke-width='10' stroke-linecap='round'/%3E%3Cline x1='50' y1='10' x2='50' y2='90' stroke='white' stroke-width='10' stroke-linecap='round'/%3E%3C/svg%3E"]; 
                    if (fallbackImg) {
                        ctx.save();
                        ctx.beginPath();
                        ctx.arc(icon.x, icon.y, radius, 0, Math.PI * 2);
                        ctx.clip();
                        ctx.drawImage(fallbackImg, drawX, drawY, size, size);
                        ctx.restore();
                    }
                }
            }
        }

        // Redraws all icons onto the main visible canvas
        function redrawIcons(icons) {
            icons.forEach(drawSingleIcon);
        }

        // Synchronous redraw: draws current lines from buffer + icons from placedIcons
        function synchronousRedraw() {
            if (!mapLoaded) return;
            
            if (isAnimating) {
                // Do nothing if animating, the animation loop handles drawing
                return; 
            }
            
            // 1. Clear the visible canvas immediately
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Draw lines from the off-screen line buffer immediately
            ctx.globalCompositeOperation = 'source-over';
            ctx.drawImage(lineBuffer, 0, 0);

            // 3. Draw icons immediately (using the current placedIcons)
            redrawIcons(placedIcons);
        }
        
        function saveState() {
            if (!mapLoaded) return;

            // FIX 1: Correctly handle array shift without corrupting the index
            if (history.length >= MAX_HISTORY_SIZE) {
                 history.shift();
                 // CRITICAL FIX: historyIndex only needs to be DECREMENTED by 1
                 historyIndex--; 
            }

            // CRITICAL FIX 2: Check if undo path exists and trim forward history before saving
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            
            // The state saves a snapshot of the pure line layer and the current icon positions (vector data)
            const newState = {
                lineData: lineBuffer.toDataURL(), // Save only the lines/strokes
                icons: JSON.parse(JSON.stringify(placedIcons)) // Deep copy of vector data for the current sequence
            };
            
            history.push(newState);
            historyIndex = history.length - 1;


            updateUndoRedoButtons();
        }

        function restoreState() {
            if (!mapLoaded || historyIndex < 0 || historyIndex >= history.length) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height); 
                // CRITICAL: PlacedIcons is reset/empty for invalid history states
                placedIcons.length = 0;
                updateUndoRedoButtons();
                return;
            }

            const state = history[historyIndex];
            
            // 1. Restore the icon array
            // Since placedIcons is an alias, we must modify its contents, not reassign it.
            placedIcons.length = 0; // Clear the array contents
            placedIcons.push(...state.icons);
            
            // --- CRITICAL FIX START: Explicitly check for history[0] ---
            if (historyIndex === 0) {
                 // The first state MUST be empty: clear icons and lines aggressively.
                 placedIcons.length = 0;
                 lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height); 
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            // Draw the icon layer immediately so the user sees the icons disappear/change instantly.
            synchronousRedraw(); 
            // --- CRITICAL FIX END ---
            
            // 2. Restore the off-screen line buffer (asynchronous due to Image load)
            const lineSnapshot = new Image();
            lineSnapshot.onload = () => {
                lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height);
                lineBufferCtx.drawImage(lineSnapshot, 0, 0);

                // 3. Render the full composite state (lines + icons) to the visible canvas
                synchronousRedraw(); 
            }
            lineSnapshot.src = state.lineData;
            
            updateUndoRedoButtons();
        }
        
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState();
            }
        }
        
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState();
            }
        }

        // =========================================================================
        // 3. DRAWING / PLACEMENT / MOVEMENT LOGIC
        // =========================================================================

        function getCanvasCoords(e) {
            let clientX, clientY;
            const target = e.touches ? e.touches[0] : e;
            clientX = target.clientX;
            clientY = target.clientY;

            const canvasRect = canvas.getBoundingClientRect();
            const x = clientX - canvasRect.left;
            const y = clientY - canvasRect.top;
            return { x, y, clientX, clientY };
        }

        // Helper function to check if coordinates are near an icon
        function getIconAtCoords(x, y) {
            for (let i = 0; i < placedIcons.length; i++) {
                const icon = placedIcons[i];
                // Determine the appropriate radius for hit detection
                const radius = icon.type === 'color' ? OPERATOR_DOT_RADIUS : UTILITY_IMAGE_DIAMETER / 2;
                
                // Check distance from click to icon center (icon radius + hit area buffer)
                const distance = Math.sqrt(Math.pow(x - icon.x, 2) + Math.pow(y - icon.y, 2));
                if (distance < radius + ICON_HIT_AREA) {
                    return i;
                }
            }
            return -1;
        }

        // Helper function to convert hex to rgba
        function hexToRgba(hex, alpha = 1.0) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }


        // NEW: Brush Preview Utility
        function updateBrushPreview(clientX, clientY, size, color, isEraser, visible) {
            if (visible && mapLoaded && (currentTool === 'pen' || currentTool === 'eraser')) {
                const halfSize = size / 2;
                brushPreview.style.width = `${size}px`;
                brushPreview.style.height = `${size}px`;
                // Position relative to the window
                brushPreview.style.transform = `translate(${clientX - halfSize}px, ${clientY - halfSize}px)`;
                brushPreview.style.opacity = '1';
                
                if (isEraser) {
                    brushPreview.style.borderColor = 'rgba(255, 255, 255, 0.8)'; // White border for contrast
                    brushPreview.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
                } else {
                    brushPreview.style.borderColor = color;
                    brushPreview.style.backgroundColor = 'transparent';
                }
                brushPreview.classList.remove('hidden');
            } else {
                brushPreview.classList.add('hidden');
                brushPreview.style.opacity = '0';
            }
        }


        function handleGlobalDraw(e) {
            const { x: currentX, y: currentY, clientX, clientY } = getCanvasCoords(e);
            
            if (currentTool === 'move') {
                if (!isMovingIcon) return;

                // --- TRASH CAN HOVER LOGIC (Uses ClientX/Y for screen coordinates) ---
                const trashRect = trashCan.getBoundingClientRect();
                const trashCanHover = (
                    clientX >= trashRect.left &&
                    clientX <= trashRect.right &&
                    clientY >= trashRect.top &&
                    clientY <= trashRect.bottom
                );

                if (trashCanHover) {
                    trashCan.classList.add('opacity-100', 'bg-red-500/90');
                    trashCan.classList.remove('bg-red-700/80', 'opacity-0');
                } else {
                    trashCan.classList.remove('opacity-100', 'bg-red-500/90');
                    trashCan.classList.add('opacity-100', 'bg-red-700/80'); // Keep visible but normal color
                }
                // --- END TRASH CAN HOVER LOGIC ---

                // Update the icon position in the vector array (Uses Canvas coordinates)
                const canvasRect = canvas.getBoundingClientRect();
                placedIcons[movingIconIndex].x = clientX - canvasRect.left;
                placedIcons[movingIconIndex].y = clientY - canvasRect.top;

                // Use synchronous redraw during drag for flicker-free movement.
                synchronousRedraw(); 
                e.preventDefault();
                return;
            }
            
            // --- DRAWING/ERASER LOGIC (Only runs if drawing started on canvas) ---
            if (!isDrawing || currentTool !== 'pen' && currentTool !== 'eraser') return;
            
            // Handle drawing/erasing logic on the off-screen buffer
            lineBufferCtx.beginPath();
            lineBufferCtx.lineJoin = 'round';
            lineBufferCtx.lineCap = 'round';
            lineBufferCtx.lineWidth = currentLineWidth;

            const isEraser = currentTool === 'eraser';
            if (isEraser) {
                lineBufferCtx.strokeStyle = 'rgba(0,0,0,1)'; 
                lineBufferCtx.globalCompositeOperation = 'destination-out';
            } else {
                // Use the currentColor (which is RGBA)
                lineBufferCtx.strokeStyle = currentColor;
                lineBufferCtx.globalCompositeOperation = 'source-over';
            }

            lineBufferCtx.moveTo(lastX, lastY);
            lineBufferCtx.lineTo(currentX, currentY);
            lineBufferCtx.stroke();

            [lastX, lastY] = [currentX, currentY];
            e.preventDefault();
            
            // Render the whole state (lines from buffer + icons) to the visible canvas synchronously
            synchronousRedraw();
            
            // Update brush preview
            updateBrushPreview(clientX, clientY, currentLineWidth, currentColor, isEraser, true);
        }

        function startInteraction(e) {
            const { x, y } = getCanvasCoords(e);
            
            if (currentTool === 'move') {
                movingIconIndex = getIconAtCoords(x, y);
                if (movingIconIndex !== -1) {
                    isMovingIcon = true;
                    // Attach global listeners for continuous dragging
                    window.addEventListener('mousemove', handleGlobalDraw); 
                    window.addEventListener('mouseup', stopInteraction);
                    window.addEventListener('touchmove', handleGlobalDraw);
                    window.addEventListener('touchend', stopInteraction);


                    [lastX, lastY] = [x, y];
                    mapContainer.style.cursor = 'grabbing';
                    
                    // Show trash can on start drag
                    trashCan.classList.remove('hidden', 'opacity-0');
                    trashCan.classList.add('opacity-100');
                    
                    // CRITICAL: Before moving, sync the current state so the position is tracked in the current sequence
                    const currentMapData = planningData[currentMapKey];
                    currentMapData[currentSequenceId].icons = JSON.parse(JSON.stringify(placedIcons)); 
                }
                return;
            }

            if (currentTool === 'pen' || currentTool === 'eraser') {
                isDrawing = true;
                [lastX, lastY] = [x, y];
                // Attach global listeners for continuous drawing
                window.addEventListener('mousemove', handleGlobalDraw);
                window.addEventListener('mouseup', stopInteraction);
                window.addEventListener('touchmove', handleGlobalDraw);
                window.addEventListener('touchend', stopInteraction);
            }
        }

        function stopInteraction(e) {
            // Remove global listeners regardless of the outcome
            window.removeEventListener('mousemove', handleGlobalDraw);
            window.removeEventListener('mouseup', stopInteraction);
            window.removeEventListener('touchmove', handleGlobalDraw);
            window.removeEventListener('touchend', stopInteraction);


            if (isDrawing) {
                isDrawing = false;
                // Since lines are drawn, save the line data for the current sequence
                const currentMapData = planningData[currentMapKey];
                currentMapData[currentSequenceId].lineData = lineBuffer.toDataURL();
                saveState(); 
            }
            
            if (isMovingIcon) {
                
                // --- DELETION CHECK ---
                let droppedInTrash = false;
                if (e && e.clientX && e.clientY) { // Ensure we have mouse coordinates
                    const trashRect = trashCan.getBoundingClientRect();
                    droppedInTrash = (
                        e.clientX >= trashRect.left &&
                        e.clientX <= trashRect.right &&
                        e.clientY >= trashRect.top &&
                        e.clientY <= trashCan.getBoundingClientRect().bottom
                    );
                }

                if (droppedInTrash && movingIconIndex !== -1) {
                    // DELETE THE ICON
                    
                    // CRITICAL FIX: Get the ID of the icon being deleted
                    const iconIdToDelete = placedIcons[movingIconIndex].id;
                    
                    // Remove from current sequence
                    placedIcons.splice(movingIconIndex, 1);
                    
                    // Remove from all SUBSEQUENT sequences
                    const currentSeqNum = parseInt(currentSequenceId.split(' ')[1]);
                    for (let i = currentSeqNum; i <= MAX_SEQUENCES; i++) { // Start checking from current sequence!
                         const nextSeqId = `Seq ${i}`;
                         let nextSeqData = planningData[currentMapKey][nextSeqId];
                         if (nextSeqData) {
                             // Use filter for deletion to maintain array integrity
                             nextSeqData.icons = nextSeqData.icons.filter(icon => icon.id !== iconIdToDelete);
                             // Line data remains untouched, as requested for sequence continuity
                         }
                    }

                    console.log('Icon deleted!');
                    synchronousRedraw();
                } else if (isMovingIcon) {
                    // If icon was MOVED (not deleted), sync the new position to ALL future sequences
                    const currentMapData = planningData[currentMapKey];
                    const movedIcon = placedIcons[movingIconIndex]; // The icon with its new position
                    const currentSeqNum = parseInt(currentSequenceId.split(' ')[1]);

                    for (let i = currentSeqNum + 1; i <= MAX_SEQUENCES; i++) {
                         const nextSeqId = `Seq ${i}`;
                         let nextSeqIcons = planningData[currentMapKey][nextSeqId].icons;
                         
                         // Find the icon in the subsequent sequence by ID
                         const targetIndex = nextSeqIcons.findIndex(icon => icon.id === movedIcon.id);

                         if (targetIndex !== -1) {
                             // If the icon exists, update its position to the new coordinates
                             nextSeqIcons[targetIndex].x = movedIcon.x;
                             nextSeqIcons[targetIndex].y = movedIcon.y;
                         } else {
                              // If the icon exists in the current seq, but is missing from a subsequent seq, add it.
                              const currentIconInPlacedIcons = placedIcons.find(icon => icon.id === movedIcon.id);
                              if (currentIconInPlacedIcons) {
                                  nextSeqIcons.push(JSON.parse(JSON.stringify(currentIconInPlacedIcons)));
                              }
                         }
                    }
                    
                    // CRITICAL: Sync the final position in the current sequence before saving history
                    currentMapData[currentSequenceId].icons = JSON.parse(JSON.stringify(placedIcons));
                }

                // Cleanup: Ensure trash can opacity is reset and hidden if tool is not 'move'
                trashCan.classList.remove('opacity-100', 'bg-red-500/90');
                trashCan.classList.add('opacity-0', 'bg-red-700/80');
                
                if(currentTool === 'move') {
                    trashCan.classList.add('hidden');
                }


                isMovingIcon = false;
                movingIconIndex = -1;
                saveState(); // Save state after icon movement or deletion
                updateCursor();
            }
            
            updateBrushPreview(0, 0, 0, null, false, false); 
        }
        
        function placeIcon(e) {
            if (currentTool !== 'place' || !mapLoaded || !selectedIcon) return;

            const { x, y } = getCanvasCoords(e);
            
            if (isDrawing) { 
                 // Save drawn line if present before placing icon (shouldn't happen often)
                 const currentMapData = planningData[currentMapKey];
                 currentMapData[currentSequenceId].lineData = lineBuffer.toDataURL();
                 saveState();
            }

            // Create a unique ID for the icon
            const baseId = selectedIcon.id;
            let count = placedIcons.filter(icon => icon.id.startsWith(baseId)).length;
            const uniqueId = `${baseId}_${count + 1}`;
            
            const newIcon = {
                id: uniqueId, // Add unique ID for tracking across sequences
                x: x, 
                y: y, 
                color: selectedIcon.color, 
                type: selectedIcon.type,
                iconUrl: selectedIcon.iconUrl || null 
            };

            placedIcons.push(newIcon);
            
            // --- CRITICAL FIX START: Copy icon to ALL subsequent sequences on placement ---
            const currentMapData = planningData[currentMapKey];
            if (currentMapData) {
                
                // 1. Check if this is the first icon ever placed on Seq 1
                const seq1Data = currentMapData['Seq 1'];
                const totalIconsPlaced = seq1Data?.icons.length || 0;
                
                if (currentSequenceId === 'Seq 1' && totalIconsPlaced === 0) {
                     // If this is the very first icon on the map, copy it forward to all sequences.
                     performInitialSequenceCopy(currentMapKey);
                } else {
                     // If an icon is placed in ANY sequence (Seq N), it must be copied to ALL subsequent sequences (N to 10).
                     const currentSeqNum = parseInt(currentSequenceId.split(' ')[1]);
                     for (let i = currentSeqNum; i <= MAX_SEQUENCES; i++) { // Start copying from the CURRENT sequence and forward
                         const nextSeqId = `Seq ${i}`;
                         const nextSeqIcons = currentMapData[nextSeqId].icons;
                         
                         // Find the icon by ID in the subsequent sequence
                         const existingIconIndex = nextSeqIcons.findIndex(icon => icon.id === newIcon.id);

                         if (existingIconIndex === -1) {
                             // If the icon doesn't exist, add it.
                             nextSeqIcons.push(JSON.parse(JSON.stringify(newIcon)));
                         } else if (nextSeqId === currentSequenceId) {
                             // If it's the current sequence, update its position (already done via push, but keep for clarity)
                             nextSeqIcons[existingIconIndex] = JSON.parse(JSON.stringify(newIcon));
                         }
                     }
                }
                
                // 2. Sync the current placedIcons array back to the active sequence structure
                currentMapData[currentSequenceId].icons = JSON.parse(JSON.stringify(placedIcons)); 
            }
            // *** END CRITICAL FIX ***

            synchronousRedraw(); 
            saveState(); 
        }

        // Clears only the lines/strokes, preserves icons
        function clearLines() {
            showConfirm("Are you sure you want to clear all drawing lines? All placed icons will remain.", (confirmed) => {
                if (confirmed) {
                    lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height);
                    
                    // CRITICAL: Save the empty state back to the current sequence line data
                    planningData[currentMapKey][currentSequenceId].lineData = lineBuffer.toDataURL();

                    synchronousRedraw();
                    saveState(); 
                }
            }, "Clear Lines");
        }

        // Clears everything (lines and icons)
        function clearDrawing(confirm = true, isMapChange = false) {
            const clearAction = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                lineBufferCtx.clearRect(0, 0, lineBuffer.width, lineBuffer.height); 
                placedIcons = []; 
                
                // CRITICAL: Clear line data for the current sequence
                if (planningData[currentMapKey] && planningData[currentMapKey][currentSequenceId]) {
                    planningData[currentMapKey][currentSequenceId].lineData = '';
                }

                if (!isMapChange) {
                    history = [];
                    historyIndex = -1;
                    saveState(); 
                }
            };

            if (confirm) {
                showConfirm("Are you sure you want to clear ALL drawings and placed icons? This cannot be undone.", (confirmed) => {
                    if (confirmed) {
                        clearAction();
                    }
                }, "Clear ALL");
            } else {
                clearAction();
            }
        }
        
        // =========================================================================
        // 4. EVENT LISTENERS
        // =========================================================================

        function updateCursor() {
             mapContainer.style.cursor = 'crosshair'; 
             
             if (currentTool === 'move') {
                 mapContainer.style.cursor = 'pointer';
             } else if (currentTool === 'place') {
                 mapContainer.style.cursor = 'pointer';
                 trashCan.classList.add('hidden');
             } else if (currentTool === 'pen' || currentTool === 'eraser') {
                 mapContainer.style.cursor = 'none';
                 trashCan.classList.add('hidden');
             } else {
                 mapContainer.style.cursor = 'crosshair';
                 trashCan.classList.add('hidden');
             }
             
             if (!isMovingIcon) {
                 trashCan.classList.remove('opacity-100');
                 trashCan.classList.add('opacity-0', 'hidden');
             }
        }

        // --- Global Keyboard Shortcuts (Ctrl+Z / Ctrl+Y) ---
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) { // MetaKey is for Cmd on Mac
                if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'y' || e.key === 'Y') {
                    e.preventDefault();
                    redo();
                }
            }
        });
        
        // --- Map Selection ---
        mapSelect.addEventListener('change', (e) => {
            currentMapIndex = parseInt(e.target.value);
            populateSectorSelector(currentMapIndex);
        });
        
        // --- Sector Selection ---
        sectorSelect.addEventListener('change', (e) => {
            const newSectorUrl = e.target.value;
            const newSectorName = e.target.options[e.target.selectedIndex].text;
            currentSectorName = newSectorName;
            loadMap(newSectorUrl);
            updateHeaderDisplay();
        });

        // --- Sequence Selection ---
        sequenceSelect.addEventListener('change', (e) => {
            switchSequence(e.target.value);
        });

        // --- Undo / Redo Buttons ---
        undoButton.addEventListener('click', undo);
        redoButton.addEventListener('click', redo);

        // --- Canvas Interactions (Mouse & Touch) ---
        canvas.addEventListener('mousedown', startInteraction);
        canvas.addEventListener('touchstart', startInteraction);
        
        // Note: mousemove/mouseup/touchmove/touchend are now attached to 'window' when dragging starts!
        
        // Handle standalone mousemove event when not drawing (to show/update preview)
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing && !isMovingIcon && (currentTool === 'pen' || currentTool === 'eraser')) {
                const { clientX, clientY } = e;
                const isEraser = currentTool === 'eraser';
                updateBrushPreview(clientX, clientY, currentLineWidth, currentColor, isEraser, true);
            }
        });
        
        // Hide preview on mouseleave from canvas (only required if not moving/drawing)
        canvas.addEventListener('mouseout', (e) => {
            if (!isMovingIcon && !isDrawing) {
                updateBrushPreview(0, 0, 0, null, false, false);
            }
        });
        
        // Use separate click handler for placing icons
        canvas.addEventListener('click', (e) => {
            if (currentTool === 'place' && !isDrawing && !isMovingIcon) {
                 placeIcon(e);
            }
        }); 

        // --- Tool Selection ---
        toolButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const newTool = e.currentTarget.dataset.tool;
                currentTool = newTool;

                // Update visual state
                toolButtons.forEach(btn => btn.classList.remove('bg-primary', 'bg-red-500'));
                toolButtons.forEach(btn => btn.classList.add('bg-gray-600'));

                e.currentTarget.classList.remove('bg-gray-600');
                if (newTool === 'pen' || newTool === 'place' || newTool === 'move') {
                    e.currentTarget.classList.add('bg-primary');
                } else if (newTool === 'eraser') {
                    e.currentTarget.classList.add('bg-red-500');
                }

                // Update visibility and cursor
                const isUtilitySelected = selectedIcon && (selectedIcon.id.startsWith('utility'));
                const isVehicleSelected = selectedIcon && (selectedIcon.id.startsWith('vehicle'));
                const isOperatorSelected = selectedIcon && (selectedIcon.id.startsWith('op'));


                placementHintOperator.classList.toggle('hidden', newTool !== 'place' || !isOperatorSelected);
                placementHintUtility.classList.toggle('hidden', newTool !== 'place' || !isUtilitySelected);
                placementHintVehicle.classList.toggle('hidden', newTool !== 'place' || !isVehicleSelected);
                
                updateCursor();
                
                // Explicitly hide preview if switching away from drawing/erasing
                if (newTool !== 'pen' && newTool !== 'eraser') {
                    updateBrushPreview(0, 0, 0, null, false, false);
                }
            });
        });
        
        // Set initial active state for the pen tool
        document.getElementById('tool-pen').click();

        // --- Settings Updates ---
        lineWidthInput.addEventListener('input', (e) => {
            currentLineWidth = parseInt(e.target.value);
            widthDisplay.textContent = `${currentLineWidth}px`;
        });

        // UPDATED: Convert hex color to RGBA for drawing opacity
        colorPicker.addEventListener('input', (e) => {
            // Defaulting to 80% opacity for the drawing line
            currentColor = hexToRgba(e.target.value, 0.8); 
        });
        
        // Ensure initial color is set to RGBA
        document.addEventListener('DOMContentLoaded', () => {
             // Use the initial hex value to set the RGBA state
             currentColor = hexToRgba(colorPicker.value, 0.8);
             preloadUtilityImages(); // Start preloading images on load
             populateVehicleSelector(); // NEW: Populate vehicle selector
        });


        // --- Clear Map & Clear Lines ---
        clearButton.addEventListener('click', () => clearDrawing(true));
        clearLinesButton.addEventListener('click', clearLines);
        
        // --- Save Map ---
        saveButton.addEventListener('click', () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            
            // Set crossOrigin attribute on the map image for safe drawing/export
            currentMapImage.crossOrigin = "Anonymous";

            const performDrawAndDownload = () => {
                // Check if the image is actually loaded and usable
                if (currentMapImage.complete && currentMapImage.naturalWidth > 0) {
                    try {
                        // Draw the map image first
                        tempCtx.drawImage(currentMapImage, 0, 0, tempCanvas.width, tempCanvas.height);
                        
                        // Draw the existing canvas content (lines/icons) on top
                        tempCtx.drawImage(canvas, 0, 0);

                        const link = document.createElement('a');
                        link.download = `df_plan_${MAPS[currentMapIndex].name.replace(/[^a-z0-9]/gi, '_')}_${currentSectorName.replace(/[^a-z0-9]/gi, '_')}.png`;
                        link.href = tempCanvas.toDataURL('image/png');
                        link.click(); 
                    } catch (e) {
                         // This catches the SecurityError (Tainted Canvas)
                         console.error("Error during canvas export (Tainted Canvas). Please run using a local web server (e.g., Live Server) or host assets online.", e);
                         
                         // Re-draw the current state to prevent visual deletion effect
                         synchronousRedraw();
                    }
                } else {
                     console.warn("Map image not ready. Cannot save.");
                     // Re-draw the current state to prevent visual deletion effect
                     synchronousRedraw();
                }
            };


            // Use an onload callback to ensure the map image is fully loaded before drawing
            // If the image is already loaded, run the function immediately.
            if (currentMapImage.complete && currentMapImage.naturalWidth > 0) {
                 performDrawAndDownload();
            } else {
                 currentMapImage.onload = performDrawAndDownload;
                 // In case onload doesn't fire, we can manually attempt to reload the source.
                 currentMapImage.src = currentMapImage.src; 
            }
        });
        
        // --- Initial Setup Calls ---
        populateMapSelector();
        populateOperatorSelector();
        populateUtilitySelector(); // NEW: Call the new utility selector

        window.addEventListener('resize', () => {
             clearTimeout(window.resizeTimeout);
             window.resizeTimeout = setTimeout(resizeCanvas, 100);
        });
        
        window.addEventListener('load', () => {
            resizeCanvas();
        });


    </script>

</body>
</html>
